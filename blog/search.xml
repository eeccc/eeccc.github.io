<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Centos7部署Python程序</title>
      <link href="/blog/2024/06/11/Centos7%E9%83%A8%E7%BD%B2Python%E7%A8%8B%E5%BA%8F/"/>
      <url>/blog/2024/06/11/Centos7%E9%83%A8%E7%BD%B2Python%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇提供一个在Centos7上部署一个Python程序的教程。Python程序被广泛开发与应用，在云服务器部署显得尤为重要，但部署过程繁琐且多坑。</p><h2 id="安装OpenSSL-1-1-x"><a href="#安装OpenSSL-1-1-x" class="headerlink" title="安装OpenSSL 1.1.x"></a>安装OpenSSL 1.1.x</h2><p>构建 Python 3.11 需要openssl 1.1.1及以上更新版本。系统存储库中可用的版本是旧的。<br>可通过如下指令查看OpenSSL版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl version</span><br></pre></td></tr></table></figure><h2 id="下载libffi-devel库"><a href="#下载libffi-devel库" class="headerlink" title="下载libffi-devel库"></a>下载libffi-devel库</h2><p>运行如下指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install libffi-devel</span><br></pre></td></tr></table></figure><p><em>如果无法下载，自行更换镜像</em></p><h2 id="安装Python3-11"><a href="#安装Python3-11" class="headerlink" title="安装Python3.11"></a>安装Python3.11</h2><p>下载Python3.11的源代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.11.9/Python-3.11.9.tgz</span><br></pre></td></tr></table></figure><p><em>如果下载比较慢，也可以从官网下载后通过SFTP传到服务器上。</em><br>提取存档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf Python-3.11.2.tgz</span><br></pre></td></tr></table></figure><p>进入到解压目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd Python-3.11*/</span><br></pre></td></tr></table></figure><p>配置构建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDFLAGS=&quot;$&#123;LDFLAGS&#125; -Wl,-rpath=/usr/local/openssl/lib&quot; ./configure --with-openssl=/usr/local/openssl</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>安装编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make altinstall</span><br></pre></td></tr></table></figure><p>查看Python版是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3.11 --version</span><br></pre></td></tr></table></figure><p>验证OpenSSL是否正常</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3.11</span><br><span class="line">import ssl</span><br><span class="line">ssl.OPENSSL_VERSION</span><br></pre></td></tr></table></figure><p>查看pip版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3.11 --version</span><br></pre></td></tr></table></figure><h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><p>如有需要，可以参考。<br><em>我还是喜欢跑全局的(<del>大不了人跑</del>)</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m venv myenv</span><br><span class="line">source myenv/bin/activate</span><br></pre></td></tr></table></figure><p>查看虚拟环境地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $VIRTUAL_ENV</span><br></pre></td></tr></table></figure><p>退出虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Centos7 </tag>
            
            <tag> Python </tag>
            
            <tag> 服务器部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastAPI调用MLP模型</title>
      <link href="/blog/2024/06/05/FastAPI%E8%B0%83%E7%94%A8MLP%E6%A8%A1%E5%9E%8B/"/>
      <url>/blog/2024/06/05/FastAPI%E8%B0%83%E7%94%A8MLP%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在实现<a href="http://pig.qrxa.net/">仔猪腹泻管理系统</a>(Piglet Diarrhea Detection System, 简称PDDS)时，为了实现系统内部可以直接智能检测病原类型，因此尝试过多种模型嵌入后端的方法。最终选取FastAPI来实现该功能。</p><h2 id="FastAPI程序"><a href="#FastAPI程序" class="headerlink" title="FastAPI程序"></a>FastAPI程序</h2><p>将Tensorflow模型的Predict代码改为FastAPI程序的调用代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, UploadFile, File</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the pre-trained TensorFlow model</span></span><br><span class="line">model = tf.keras.models.load_model(<span class="string">&#x27;./model&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the class labels for the model predictions</span></span><br><span class="line">class_labels = [<span class="string">&quot;health&quot;</span>, <span class="string">&quot;Ecoli&quot;</span>, <span class="string">&quot;rotavirus&quot;</span>, <span class="string">&quot;coronavirus&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the target size for image resizing</span></span><br><span class="line">img_height = <span class="number">224</span></span><br><span class="line">img_width = <span class="number">224</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the FastAPI application</span></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the prediction response model</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Prediction</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    filename: <span class="built_in">str</span></span><br><span class="line">    prediction: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the prediction endpoint</span></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/predict&quot;</span>, response_model=Prediction</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">file: UploadFile = File(<span class="params">...</span>)</span>):</span><br><span class="line">    <span class="comment"># Read the uploaded image file</span></span><br><span class="line">    contents = <span class="keyword">await</span> file.read()</span><br><span class="line">    <span class="comment"># Convert the image file to a NumPy array</span></span><br><span class="line">    np_img = np.frombuffer(contents, np.uint8)</span><br><span class="line">    <span class="comment"># Decode the image from the NumPy array</span></span><br><span class="line">    img = cv2.imdecode(np_img, cv2.IMREAD_COLOR)</span><br><span class="line">    <span class="comment"># Resize the image to the target size</span></span><br><span class="line">    img = cv2.resize(img, (img_height, img_width))</span><br><span class="line">    <span class="comment"># Convert the image to a NumPy array</span></span><br><span class="line">    img_array = np.array(img)</span><br><span class="line">    <span class="comment"># Ensure the image array is of type uint8</span></span><br><span class="line">    img_array = img_array.astype(np.uint8)</span><br><span class="line">    <span class="comment"># Expand dimensions to match the model&#x27;s input shape</span></span><br><span class="line">    img_array = np.expand_dims(img_array, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make a prediction using the model</span></span><br><span class="line">    predictions = model.predict(img_array)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get the index of the highest probability class</span></span><br><span class="line">    predicted_class_index = np.argmax(predictions[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># Map the index to the corresponding class label</span></span><br><span class="line">    predicted_class = class_labels[predicted_class_index]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the prediction result</span></span><br><span class="line">    <span class="keyword">return</span> Prediction(filename=file.filename, prediction=predicted_class)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run the FastAPI application</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> uvicorn</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Start the Uvicorn server to serve the FastAPI application</span></span><br><span class="line">    uvicorn.run(app=<span class="string">&#x27;main:app&#x27;</span>, host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">8000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在终端运行如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uvicorn main:app --reload</span><br></pre></td></tr></table></figure><p>即可启动</p><h2 id="Request测试代码"><a href="#Request测试代码" class="headerlink" title="Request测试代码"></a>Request测试代码</h2><p>提供一个request.py的demo代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the URL of the FastAPI prediction endpoint</span></span><br><span class="line">url = <span class="string">&quot;http://127.0.0.1:8000/predict&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Path to the image file you want to upload</span></span><br><span class="line">image_path = <span class="string">&quot;./img/111.jpg&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Open the image file in binary mode</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(image_path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> image_file:</span><br><span class="line">    <span class="comment"># Prepare the files dictionary with the image file</span></span><br><span class="line">    files = &#123;<span class="string">&quot;file&quot;</span>: image_file&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Send a POST request to the FastAPI endpoint</span></span><br><span class="line">    response = requests.post(url, files=files)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print the response from the server</span></span><br><span class="line">    <span class="built_in">print</span>(response.json())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在运行该代码之前，要将主程序跑起来。</p><h2 id="Java后端调用代码"><a href="#Java后端调用代码" class="headerlink" title="Java后端调用代码"></a>Java后端调用代码</h2><p>API主要目的为JAVA后端可以调用，因此提供一个小demo。我们使用OkHttp库来实现该操作。<br>首先添加依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;okhttp&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.9</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>JAVA代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> okhttp3.*;</span><br><span class="line"><span class="keyword">import</span> org.json.JSONArray;</span><br><span class="line"><span class="keyword">import</span> org.json.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastApiClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">                .connectTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">                .writeTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">                .readTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8000/predict&quot;</span>;</span><br><span class="line"></span><br><span class="line">        MultipartBody.<span class="type">Builder</span> <span class="variable">multipartBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultipartBody</span>.Builder().setType(MultipartBody.FORM);</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">folder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;G:/mlp/test_data/coronavirus&quot;</span>);</span><br><span class="line">        File[] listOfFiles = folder.listFiles();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (listOfFiles != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File file : listOfFiles) &#123;</span><br><span class="line">                <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                    multipartBuilder.addFormDataPart(<span class="string">&quot;files&quot;</span>, file.getName(),</span><br><span class="line">                            RequestBody.create(file, MediaType.parse(<span class="string">&quot;image/jpeg&quot;</span>)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">RequestBody</span> <span class="variable">requestBody</span> <span class="operator">=</span> multipartBuilder.build();</span><br><span class="line"></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .post(requestBody)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Unexpected code &quot;</span> + response);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">responseBody</span> <span class="operator">=</span> response.body().string();</span><br><span class="line">            <span class="type">JSONArray</span> <span class="variable">jsonArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONArray</span>(responseBody);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; jsonArray.length(); i++) &#123;</span><br><span class="line">                <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> jsonArray.getJSONObject(i);</span><br><span class="line">                <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;filename&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">prediction</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;prediction&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Image &quot;</span> + filename + <span class="string">&quot; is predicted as: &quot;</span> + prediction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> FastAPI </tag>
            
            <tag> MLP </tag>
            
            <tag> Tensorflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玉米雄穗的检测和计数</title>
      <link href="/blog/2024/05/27/%E7%8E%89%E7%B1%B3%E9%9B%84%E7%A9%97%E7%9A%84%E6%A3%80%E6%B5%8B%E5%92%8C%E8%AE%A1%E6%95%B0/"/>
      <url>/blog/2024/05/27/%E7%8E%89%E7%B1%B3%E9%9B%84%E7%A9%97%E7%9A%84%E6%A3%80%E6%B5%8B%E5%92%8C%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="材料与方法"><a href="#材料与方法" class="headerlink" title="材料与方法"></a>材料与方法</h2><h3 id="数据集的构建与标注"><a href="#数据集的构建与标注" class="headerlink" title="数据集的构建与标注"></a>数据集的构建与标注</h3><p>将原始的80张分辨率为5472*3648的图片按相同比例分割成480张分辨率为1824*1824的小图，裁剪掉有其他视觉干扰的图像并对图片进行筛选和分类。 最终得到253张正常图片，56张玉米穗形态杂乱图片，28张土壤干扰因素大图片，50张存在黄叶图片和40张光照较强图片。</p><p>使用Label-Studio工具对选取的10%数据图片进行标注，并将标注得到的数据集按照train:val≈7:3的比例划分，得到最终的数据集。</p><h3 id="网络模型的选择"><a href="#网络模型的选择" class="headerlink" title="网络模型的选择"></a>网络模型的选择</h3><p>玉米田间存在大量的杂草、杂物等干扰物，并且由于拍摄时间、角度的不同，玉米雄穗的视觉特征在玉米种植密度和不同气象条件下的表达存在差异。 模型训练提取特征信息困难，使得在模型在实际场景的检测中容易出错，因此应当选择目前阶段较为先进的目标检测模型来进行试验。</p><p>YOLO(You Only Look Once)系列因其在目标检测任务中的高速度和准确性而闻名。近几年，YOLO持续发展并不断改进，被广泛应用于深度学习之中。 YOLOv8是由Ultralytics公司开发的最新一代目标检测算法，它是YOLO系列的重要迭代产品。 YOLOv8属于单阶段目标检测网络，YOLOv8将YOLOv5中Backbone里的C3模块更换成了梯度流更丰富的C2f模块，缩减了骨干网络中最大stage的blocks数，进一步减少参数量和计算量，实现轻量化。 YOLOv8加入采用了无锚点(Anchor-Free)检测头和最新的损失函数，与基于锚点的方法相比，有助于提高检测过程的准确性和效率，使得模型在预测目标位置时更加灵活和准确。<br><img src="/blog/images/tassel/%E9%AB%98%E6%B8%85_%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="高清_架构图.jpg" title="YOLOv8网络架构"></p><p>半监督学习在标记数据稀缺但未标记数据较多的情况下取得了长足的进步，其结合了监督学习的判别能力和非监督学习的泛化能力。 半监督学习能够利用少量标注的数据以及大量未标注的数据进行训练，通过结合有标签和无标签数据，有助于提高模型对于未见数据的预测准确度，从而增强模型的泛化能力。</p><p>自训练(self-training)方法是半监督学习中最典型的方法之一，因其简单性和有效性在实际应用中备受青睐。 其主要流程是利用已有的标签数据对模型进行训练，再对为未标注数据进行预测并生成伪标签，将其选择性的加入训练数据集中，并重复此过程直到模型指标稳定或达到训练效果。 自训练方法的关键点在于如何有效地从未标记数据中生成高质量的伪标签，并且如何控制这些伪标签对模型训练的影响，以避免引入噪声和错误标签。在本试验中，利用不同置信度下的迭代训练来弱化某次错误的伪标签所带来的负面影响。</p><p>伪标签(Pseudo-label)是目前半监督学习的重要组成部分，伪标签技术的核心思想是利用已标注数据训练的模型对未标注数据进行预测，生成伪标签，然后选择置信度高的伪标签样本与原始标注数据一起用于进一步训练模型。 预测筛选过程中将概率最大的标签作为伪标签，形式化后等价于熵正则化(Entropy Regularization)或熵最小化(Entropy Minimization)。</p><p>综上，本试验将半监督学习的思想融入YOLOv8模型训练之中，即SSL-YOLOv8模型。 采用平滑性假设和聚类假设，使用自训练方法来实现该模型。先使用10%的标签数据对模型进行预训练；用该模型来识别余下90%的无标签数据并生成伪标签，在该过程中通过置信度筛选伪标签来确保模型在有标签和无标签数据上的预测保持一致性；将伪标签按8:2比例分割融入数据集，再次训练模型，并将此过程不断迭代，直到达到预期效果。<br><img src="/blog/images/tassel/%E6%94%B9%E7%89%88_SSL-YOLOv8%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="改版_SSL-YOLOv8流程图.png" title="SSL-YOLOv8流程图"></p><p>Algorithm 1描述了该程序实现的主要流程，其中S为已标注数据集，T为未标注数据集，S’为S数据集和伪标签数据集P的混合数据集，并迭代训练模型M’。</p><table><thead><tr><th>Algorithm 1 SSL-YOLOv8 main processes</th></tr></thead><tbody><tr><td><strong>Input:  Training datasets set S &#x3D; {Labeled Data} and T &#x3D; {Unlabeled Data}</strong></td></tr><tr><td>&ensp;&ensp;&ensp;&ensp;1.Pre-training model M using datasets S</td></tr><tr><td>&ensp;&ensp;&ensp;&ensp;2.For img &#x3D; 1:lenth(T)</td></tr><tr><td>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;3.Predict img using model M</td></tr><tr><td>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;4.Get pseudo label pi &#x3D; {IF conf &gt; x}</td></tr><tr><td>&ensp;&ensp;&ensp;&ensp;5.End For</td></tr><tr><td>&ensp;&ensp;&ensp;&ensp;6.Set pseudo labeled datasets P &#x3D; {p1, p2, …, pn}</td></tr><tr><td>&ensp;&ensp;&ensp;&ensp;7.Set S’ &#x3D; S ∪ P</td></tr><tr><td>&ensp;&ensp;&ensp;&ensp;8.Self-training model M’ using datasets S’</td></tr><tr><td>&ensp;&ensp;&ensp;&ensp;9.Cycle steps2~8 three times</td></tr><tr><td><strong>Output:  Final model M’</strong></td></tr></tbody></table><h2 id="试验与结果分析"><a href="#试验与结果分析" class="headerlink" title="试验与结果分析"></a>试验与结果分析</h2><h3 id="试验设备和环境"><a href="#试验设备和环境" class="headerlink" title="试验设备和环境"></a>试验设备和环境</h3><p>该试验运行在Linux系统上，处理器为Intel(R) Xeon(R) Gold 6330，显卡为RTX 3090(24GB)。统一计算设备架构(CUDA)版本为11.8，深度学习框架为Pytorch 2.0.0，编程语言为Python 3.8。</p><h3 id="试验评价指标"><a href="#试验评价指标" class="headerlink" title="试验评价指标"></a>试验评价指标</h3><p>本试验主要使用YOLO模型中最常见的性能评价指标对结果进行评估，如查准率(precision，P)，召回率(recall，R)以及mAP。将Precision设为纵坐标，Recall设为横坐标，得到P-R曲线，其曲线下的面积即为AP，所有类别AP值的平均值为mAP。<br>查准率、召回率和mAP的计算公式如下：<br>$$P&#x3D;\frac{TP}{TP+FP}$$<br>$$R&#x3D;\frac{TP}{TP+FN}$$<br>$$mAP&#x3D;\frac{1}{N}\textstyle\sum_{i&#x3D;1}^n AP_i$$</p><p>其中公式(1)与(2)中TP(True Positive)表示实际玉米穗被预测为玉米穗的样本量，公式(1)中FP(False Positive)表示实际为非玉米穗被预测为玉米穗的样本量，公式(2)中FN(False Negative)表示实际为非玉米穗被预测为非玉米穗的样本量，公式(3)中N为预测样本的类别数量。<br>本试验中mAP指标为mAP@0.5与mAP@0.5:0.95，其中mAP@0.5表示IoU阈值为0.5的mAP，mAP@0.5:0.95表示从0.5到0.95多个IoU阈值(如0.5、0.55、0.6、0.65、0.7、0.75、0.8、0.85、0.9、0.95)下的平均值。</p><h3 id="性能结果与分析"><a href="#性能结果与分析" class="headerlink" title="性能结果与分析"></a>性能结果与分析</h3><p>为了验证本试验方法的可行性，本试验和不同版本的YOLO模型的监督训练进行对比。从试验指标以及对于测试集的预测结果来看，在相同数据集训练下，各模型均能预测出玉米穗。而本试验仅需标注数据集的10%即可达到监督训练的效果，大大减少了标签获取成本和难度。<br>预测图对比见图3，YOLOv5、YOLOv7、YOLOv8可能出现预测不准或重框的情况出现，而本试验模型(SSL-YOLOv8)预测结果准确、稳定。从对比结果来看，本试验模型的预测准度和泛化能力均胜于监督训练的模型。</p><table><thead><tr><th><img src="/blog/images/tassel/%E7%AC%AC%E4%B8%89%E7%89%88_%E7%A8%A0%E5%AF%86%E5%9B%BE%E5%AF%B9%E6%AF%94.jpg" alt="第三版_稠密图对比.jpg"></th><th><img src="/blog/images/tassel/%E7%AC%AC%E4%B8%89%E7%89%88_%E5%BC%BA%E5%85%89%E5%9B%BE%E5%AF%B9%E6%AF%94.jpg" alt="第三版_强光图对比.jpg"></th></tr></thead><tbody><tr><td><img src="/blog/images/tassel/%E7%AC%AC%E4%B8%89%E7%89%88_%E5%B0%8F%E7%A9%97%E5%9B%BE%E5%AF%B9%E6%AF%94.jpg" alt="第三版_小穗图对比.jpg"></td><td><img src="/blog/images/tassel/%E7%AC%AC%E4%B8%89%E7%89%88_%E5%9C%9F%E5%A3%A4%E5%9B%BE%E5%AF%B9%E6%AF%94.jpg" alt="第三版_土壤图对比.jpg"></td></tr></tbody></table><p>本试验训练轮数总共为200个epochs，预训练和三次自训练分别为50个epochs，在后50次epochs训练中指标数值达到稳定状态，如图4。<br><img src="/blog/images/tassel/result.png" alt="result.png"></p><h3 id="不同模型的对比分析"><a href="#不同模型的对比分析" class="headerlink" title="不同模型的对比分析"></a>不同模型的对比分析</h3><p>对于不同YOLO版本模型的训练结果对比来看，本试验模型(SSL-YOLOv8)的mAP@0.5略高于其他模型，mAP@0.5:0.95数值相对于其他模型的数值大幅提升，如图5。说明本试验模型在保证YOLO良好的识别效果上，提高了预测的准确率与目标检测的泛化能力，降低了人工标注数据的错误率。<br><img src="/blog/images/tassel/%E9%AB%98%E6%B8%85_%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACmAP%E5%AF%B9%E6%AF%94.jpg" alt="高清_不同版本mAP对比.jpg"></p><p>不同模型预测结果的热可视化图，如图6。通过热图(HeatMap)可以看到模型在预测过程中最关注的影像区域，能够较为直观的展示出模型在识别过程中是否关注了正确的图像区域。从热图结果对比来看，本试验模型(SSL-YOLOv8)的检测精度与其他模型相近，本模型的泛化能力要强于其他模型，代表半监督学习思想在提高模型泛化能力方面表现出色。<br><img src="/blog/images/tassel/%E6%94%B9%E7%89%88_%E7%83%AD%E5%9B%BE%E5%AF%B9%E6%AF%94.jpg" alt="改版_热图对比.jpg"></p><p>为了减小试验的偶然性，在相同硬件的环境和相似的参数下，不同模型在相同的数据集上进行对比测试。对比试验的最终性能指标结果如表1所示，由表可知SSL-YOLOv8的查准率、召回率、mAP@0.5和mAP@0.5:0.95分别达到了96%、94%、98%、81.6%，对比其他YOLO版本的原模型性能指标均有显著提升。说明SSL-YOLOv8在算法性能上表现出色，泛化能力更好。</p><table><thead><tr><th>模型</th><th>P&#x2F;%</th><th>R&#x2F;%</th><th>mAP@0.5&#x2F;%</th><th>mAP@0.5:0.95&#x2F;%</th></tr></thead><tbody><tr><td>YOLOv5</td><td>96</td><td>91</td><td>95</td><td>65</td></tr><tr><td>YOLOv7</td><td>95</td><td>93</td><td>96</td><td>70</td></tr><tr><td>YOLOv8</td><td>95</td><td>92</td><td>96</td><td>69</td></tr><tr><td>SSL-YOLOv8</td><td>96</td><td>94</td><td>98</td><td>81.6</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> YOLO </tag>
            
            <tag> 目标检测 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 半监督 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
